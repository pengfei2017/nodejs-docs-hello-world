# 安装docker 参考地址：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository
sudo yum install -y yum-utils device-mapper-persistent-data lvm2

sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
    
sudo yum-config-manager --enable docker-ce-edge

sudo yum makecache fast

sudo yum install docker-ce

# 安装特定版本
列出所有可用版本
yum list docker-ce.x86_64  --showduplicates | sort -r
指定版本号进行安装
sudo yum install docker-ce-<VERSION>

# 启动Docker
sudo systemctl start docker

# 在JenkinsServer上用下面的Dockerfile文件构建jenkins镜像
Dockerfile文件内容如下
FROM jenkinsci/blueocean:latest
USER root
ADD https://get.docker.com/builds/Linux/x86_64/docker-17.05.0-ce.tgz .
RUN mv docker/docker /usr/bin/ && rm -rf docker
USER $USER

编译images
sudo docker build -t reg.chuangjiangx.com/jenkins:lateat .

#启动Jenkins服务器
docker run -d -p 80:8080 -p 50000:50000 -v /var/run/docker.sock:/var/run/docker.sock -v /jenkins_home:/var/jenkins_home reg.chuangjiangx.com/jenkins:lateat
docker logs <容器名或者容器ID> 查看登录Jenkins的初始密码

# 在DockerManager1服务器上安装java
访问 Oracle JDK download page, 查看 RPM version.
复制 jdk-8u102-linux-x64.rpm 的下载地址并用下面的 wget 下载它
wget --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.rpm
用yum localinstall安装
sudo yum localinstall jdk-8u141-linux-x64.rpm
删除下载的安装包
rm ~/jdk-8u141-linux-x64.rpm -f
现在 JDK 应该被安装在 /usr/java/中
cd /usr/java
ls -lsah
验证是否安装好
java -version
cd ~/
编辑 .bash_profile文件， append the export JAVA_HOME at the end of the file, for example :
vim .bash_profile

export JAVA_HOME=/usr/java/jdk1.8.0_141/
export JRE_HOME=/usr/java/jdk1.8.0_141/jre

PATH=$PATH:$HOME/bin:$JAVA_HOME/bin

测试环境变量是否设置好
source .bash_profile
java -version
echo $JRE_HOME
echo $JAVA_HOME
echo $PATH

安装了多个版本的java，可以使用下面命令设置默认的java版本
If the CentOS has multiple JDK installed, you can use the alternatives command to set the default java
sudo alternatives --config java

# 在DockerManager1上执行 docker swarm init --advertise-addr 116.62.58.231  ，然后在DockerWorker1和DockerWorker2工作主机上执行命令，加入DockerManager1的docker集群

====================================
# 每一个作为工作主机加入到docker集群的主机上需要安装docker
# 每一个作为管理主机加入到docker集群的主机上需要安装docker和java,还有git
centos安装git用命令yum install git-core
ubuntu安装git用命令apt-get install git

# 在DockerRegistryServer服务器上配置证书和密码
cd /registry/
#生成本地证书或者把第三方证书拷贝到这里
mkdir certs && cd certs
生成用户和密码
mkdir auth && cd auth
docker run --entrypoint htpasswd registry:2 -Bbn hepengfei hpf20140731 > htpasswd
创建启动registry的启动文件
cd /registry/
vim docker-compose.yml
粘贴以下内容到docker-compose.yml文件
registry:
  restart: always
  image: registry:2
  ports:
    - 443:5000
  environment:
    REGISTRY_HTTP_TLS_CERTIFICATE: /certs/fullchain.pem  
    REGISTRY_HTTP_TLS_KEY: /certs/privkey.pem
    REGISTRY_AUTH: htpasswd
    REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd
    REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm
  volumes:
    - /registry/data:/var/lib/registry
    - /registry/certs:/certs
    - /registry/auth:/auth
    
注：上面文件中environment中的/certs/fullchain.pem指的是image: registry:2的容器中的/certs目录，由volumes下面挂载到- /registry/certs:/certs本机的/registry/certs目录

安装docker-compose工具 访问链接地址安装最新版：https://github.com/docker/compose/releases
curl -L https://github.com/docker/compose/releases/download/1.15.0-rc1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
启动registry服务
docker-compose up -d
如果端口被占用，使用netstat -ntlp | grep 80查看哪个进程占用80端口 20874/nginx: master
用ps 20874 查看进程的详细信息
用kill -9 20874杀死进程

查看registry服务是否是UP状态
docker ps -a | grep registry

# 用用户名和密码查看镜像库中有哪些镜像
curl https://hepengfei:hpf20140731@reg.chuangjiangx.com/v2/_catalog

# 编译本地项目maven镜像
#进入原maven内部
docker run -it reg.chuangjiangx.com/maven bash
换成阿里云的镜像站
进入目录
cd /etc/apt/
备份镜像源文件
cp sources.list sources.list.bak
清空源文件
echo '' > sources.list
换成阿里云的镜像源地址
echo 'deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib' > sources.list
安装vim编辑器
apt-get update
apt-get install vim
编辑maven的配置文件，换成阿里云的maven包下载地址，要不然会报找不到一些阿里支付的pom包的错误
cd /usr/share/maven/conf/
vim settings.xml
添加下面两段代码
<mirror>
		<id>nexus-osc</id>
		<mirrorOf>central</mirrorOf>
		<name>Nexus osc</name>
		<url>http://114.55.50.30/nexus/content/groups/public/</url>
    </mirror>
    
    和
<profile>
        <id>jdk-1.4</id>

        <activation>
            <jdk>1.4</jdk>
        </activation>
      	<repositories>
			<repository>
				<id>private nexus</id>
				<url>http://114.55.50.30/nexus/content/groups/public/</url>
				<releases>
				  <enabled>true</enabled>
				</releases>
				<snapshots>
				  <enabled>true</enabled>
				</snapshots>
			</repository>
		</repositories>
		<pluginRepositories>
			<pluginRepository>
				<id>nexus</id>
				<name>local private nexus</name>
				<url>http://114.55.50.30/nexus/content/groups/public/</url>
				<releases>
					<enabled>true</enabled>
				</releases>
				<snapshots>
					<enabled>false</enabled>
				</snapshots>
			</pluginRepository>
		</pluginRepositories>
    </profile>
提交镜像
exit 退出原maven的容器内部
docker ps 查看刚才编辑的容器的容器ID
docker commit <容器名或者容器ID> reg.chuangjiangx.com/maven
把新的maven镜像推到私有镜像服务器
docker push reg.chuangjiangx.com/maven
根据项目中Dockerfile.maven文件构建reg.chuangjiangx.com/agent-backend-maven镜像
docker build -f ./dockerfiles/Dockerfile.maven  -t reg.chuangjiangx.com/agent-backend-maven .

---------Dockerfile.maven文件内容--------
FROM reg.chuangjiangx.com/maven:latest
MAINTAINER <author 贺鹏飞>

# 这个文件也可以用这行命令代替docker run -it --rm --name my-maven-project -v "$PWD":/usr/src/mymaven -w /usr/src/mymaven maven:3.2-jdk-7 mvn clean install

ADD . /usr/src/mymaven

WORKDIR /usr/src/mymaven

RUN mvn clean install -DskipTests

# 这里别用WORKDIR /usr/src/mymaven/agent-backend-web，一定要用RUN cd /usr/src/mymaven/agent-backend-web，因为一旦用WORKDIR，由于上下文环境变了，打包agent-backend-web时无法拿到这个工作上下文空间以外的agent-backend-common中生成的jar包
RUN cd /usr/src/mymaven/agent-backend-web

CMD ["mvn", "clean", "package", "-DskipTests", "-Pprod"]
----------------------------------------

把reg.chuangjiangx.com/agent-backend-maven推送到镜像库
docker push reg.chuangjiangx.com/agent-backend-maven
在项目中运行镜像容器进行编译项目
docker run -it --rm --name agent-backend-maven -v $(pwd):/usr/src/mymaven reg.chuangjiangx.com/agent-backend-maven

# 在Jenkins中设置触发远程构建
安装Role-based Authorization Strategy插件
在Jenkins-->用户--->找到一个用户
这里选hepengfei，因为前面所有操作都是基于此账户操作的
然后点击hepengfei,在左边栏选择->设置-->点击show API Token

http://hepengfei:6e43d38d26d6aae2daab81693cadb15d@116.62.138.243/job/agent/build?token=agent_token

# 在Jenkins中安装Copy Artifact Plugin插件

jenkins参考教程：https://berlin.gitbooks.io/jenkins/content/job/gou_jian_de_hong_fa_qi.html

# 编译前段agent项目
下载node镜像
docker pull node
将node镜像推送到私有镜像库,这样再拉取node镜像时会快很多
docker tag node reg.chuangjiangx.com/node:latest
docker push reg.chuangjiangx.com/node:latest

docker build -f ./dockerfiles/Dockerfile.node  -t reg.chuangjiangx.com/agent-node .
==========Dockerfile.node文件内容如下============
FROM reg.chuangjiangx.com/node:latest
MAINTAINER <author 贺鹏飞>

# docker run -it --rm --name my-running-script -v "$PWD":/usr/src/app -w /usr/src/app node:4 node your-daemon-or-script.js

ADD . /usr/src/app

WORKDIR /usr/src/app

# 安装阿里的cnpm,这样安装npm install时用阿里的镜像源，速度更快 参考地址：https://npm.taobao.org/
RUN npm install -g cnpm --registry=https://registry.npm.taobao.org

# 用阿里的镜像进行npm install安装
RUN cnpm install

CMD ["node", "./node_modules/gulp/bin/gulp.js", "--color", "--gulpfile", "./gulpfile.js", "default"]
===============================================
不能写成下面这样
docker run -it --rm --name agent-node -v $(pwd):/usr/src/app reg.chuangjiangx.com/agent-node
一定要写成下面这样
docker run -it --rm --name agent-node -v $(pwd)/dist:/usr/src/app/dist reg.chuangjiangx.com/agent-node
上面的区别在于，node有一个bug,当用npm install时，如果挂载$(pwd):/usr/src/app，npm install安装完就没有node_modules文件夹了，所以只挂载需要输出的编译后的dist包就好

docker build -f ./dockerfiles/Dockerfile.runjava -t reg.chuangjiangx.com/agent-backend-runjava .
docker run -it --rm --name agent-backend-runjava -p 8080:8080 -v $(pwd)/logs/agent:/var/logs/agent reg.chuangjiangx.com/agent-backend-runjava

如果配置好的job在docker-manager1主机上报无法克隆远程代码的错误，那是因为docker-manager1上没有安装git，用下面命令在docker-manager1上安装git就好
centos安装git用命令yum install git-core
ubuntu安装git用命令apt-get install git

向集群中加入一台管理主机的命令查看
docker swarm join-token manager
向集群中加入一台工作主机的命令查看
docker swarm join-token worker

更新管理员节点的状态使他只做管理任务不接受任何worker任务
docker node update --availability drain <hostname或者id(用docker node ls查看)>

在docker集群的管理员主机上执行以下命令向集群中工作主机发布一个多容器应用
docker stack deploy --compose-file ./dockerfiles/docker-stack.yml agent-web --with-registry-auth
注：--with-registry-auth一定要加上，不然发布镜像时因worker主机上没有登录私有镜像库，无权拉取镜像，所以会报No such image...的错误
=============docker-stack.yml文件内容如下=========
version: '3.1'

services:

    agent-web-server:
        image: reg.chuangjiangx.com/agent-backend-runjava
        # mount point for application
        volumes:
            - AgentLogs:/var/logs/agent
        ports:
            - "80:9099"
        networks:
            - agent-net
        deploy:
            replicas: 2
            update_config:
                parallelism: 2
            restart_policy:
                condition: on-failure

volumes:
    AgentLogs:

networks:
    agent-net:
        driver: overlay

==============================================

查看发布后的多容器应用已经启动的所有服务以及节点分配
docker stack services agent-web

# 查看当前集群中共部署了几个stack
docker stack ls
#查看发布后的agent-web应用的每个服务是否有错误
docker stack ps agent-web
docker stack services agent-web

#修改ubuntu主机名
sudo vim /etc/hostname
sudo vim /etc/hosts
把上面两个文件中对应的主机名修改掉重启系统即可

#管理容器的卷
docker volume

#在主机和容器之间拷贝文件
把f1802a743d7d容器中的/etc/apache2/apache2.conf文件拷贝到主机当前目录下
docker cp f1802a743d7d:/etc/apache2/apache2.conf ./
把主机当前目录下的apache2.conf文件拷贝到f1802a743d7d容器的/etc/apache2/目录下
docker cp ./apache2.conf f1802a743d7d:/etc/apache2/ 

# 启动mysql
docker run -d --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw mysql
# docker exec -it 可以让我们进入一个已经运行的容器内部，并提供一个容器内部的bash shell
docker exec -it some-mysql bash

# 网易邮箱账号
hepengfei2017@163.com
密码：hpf20140731
POP3/SMTP服务 授权码：hpf20140731hpf

# 参数化构建过程，选择git tag标签进行构建，参考链接：http://www.sohu.com/a/132990772_472899

# 退出私有镜像库
docker logout reg.chuangjiangx.com

# Docker RUN与CMD vs ENTRYPOINT的区别
http://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/

scp -r ./* root@116.62.143.73:~/agent

#----------------------------------------
Docker运行后自动退出的解决办法？

Docker是一个应用程序容器引擎。使用它，我们可以将任何Linux软件打包成一个独立的，隔离的容器映像，可以轻松地分发，并在任何主机上运行。一旦我们建立或下
载了图像，我们可以使用它来启动容器，我们想要并运行它们上的软件。

昨天，在Docker的图像上开始进行一些处理时，我遇到了一些问题，我将在本博客中解释一下我用来解决这个问题的解决方案。我希望它会帮助某人。

问题  ：根据Docker教程，我读到目前为止，使用“ docker run [OPTIONS] IMAGE [：TAG | @DIGEST] [COMMAND] [ARG ...]”  将从图像启动容器，容器
将运行。但在我的情况下，它不是。

如果我跑了“ docker ps”，没有任何输出。
我试过“ docker ps -a”，我可以看到容器已经退出了：
mohit.chandra@mohit106:/home/mohit/docker# docker ps -a
CONTAINER_ID    IMAGE            COMMAND                 CREATED        STATUS         NAMES
a581778502e9    webkul/odoo:v10  "/docker-entrypoint.s"  2 minutes ago  Exited(126)    dare_dev

这是Dockerfile的内容：
FROM webkul/odoo
MAINTAINER Mohit Chandra <mohit@webkul.com>
 
# Expose Odoo/Postgresql services
EXPOSE 8069 5432
 
# Copy Entrypoint script in the container
COPY ./docker-entrypoint.sh /
 
ENTRYPOINT ["/docker-entrypoint.sh"]

这里是脚本文件（docker-entrypoint.sh）的内容：
set -e
echo "Starting PostgreSQL..."
service postgresql start
echo "Starting ODOO..."
service odoo-server start

我尝试了许多事情，Google，但没有任何作用。感谢Stackoverflow，我发现了这个背后的原因，

原因：Docker需要在前台继续运行命令。否则，它认为该应用程序已停止，并关闭该容器。由于我的脚本（docker-entrypoint.sh）仅包含后台进程，并且之后没有
其他前台进程触发，这就是为什么在脚本结束时容器自动退出的原因。

解决方案：为了解决这个问题，我们需要在前台运行某些东西，或者使用一个进程管理器（如runit或supervisord）来运行进程。

这个行为让我很长一段时间，最后通过Hit-n-Try方法，我得到了更好的技巧来解决这个问题，这里是：

在脚本末尾添加额外的命令，如：
set -e
echo "Starting PostgreSQL..."
service postgresql start
echo "Starting ODOO..."
service odoo-server start
#Extra line added in the script to run all command line arguments
exec "$@";

并在运行码头图像时提供一些[COMMAND]，如：
#To open container with a shell prompt
docker run -it webkul/odoo:v10 /bin/bash
 
or
 
#To start a container in detached mode
docker run -dit webkul/odoo:v10 /bin/bash
那就是！我希望将来会帮助某人。和我最有可能意味着我的人！
#----------------------------------------

我注意到，docker的许多entrypoint.sh脚本都是这样的：

#!/bin/bash
set -e

... code ...

exec "$@"
什么是set -e和exec "$@"，为什么要用这两个？
set -e - 如果任何命令失败，则退出脚本（非零值）
exec "$@"- 将重定向输入变量，在这里看到更多
